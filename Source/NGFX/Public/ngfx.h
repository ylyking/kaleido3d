/**
This header was generated by `sappheiros` (https://github.com/Tomicyo/sappheiros)
Copyright (c) 2017 Tsin Studio

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
**/
#pragma once
#ifndef __NGFX__
#define __NGFX__
#include <stdint.h>
#include <string.h>
#include <ngfx_atomic.h>
#include <ngfx_allocator.h>
#include <ngfx_container.h>
#if ENABLE_UNITY_PLUGIN
    #include <IUnityGraphics.h>
#endif

#if _WIN32
  #if defined(LIB_BUILD)
    #if defined(BUILD_SHARED_LIB)
      #define NGFX_API __declspec(dllexport)
    #else
      #define NGFX_API __declspec(dllimport)
    #endif
  #else
    #define NGFX_API     
  #endif
#else
  #define NGFX_API __attribute__((visibility("default"))) 
#endif

#if _MSC_VER
#define Nullable _In_opt_
#define NotNull _In_
#else
#define Nullable  
#define NotNull  
#endif

typedef float    Float32;
typedef uint32_t Bool32;
typedef struct   Float32x4 { Float32 x,y,z,w;
#if __cplusplus
                 Float32x4(Float32 _x = 0, Float32 _y = 0, Float32 _z = 0, Float32 _w = 0)
                 : x(_x), y(_y), z(_z), w(_w) {}
#endif
                 } Float32x4;

// Result of every call
typedef enum ngfxResult
{
  NGFX_RESULT_OK,
  NGFX_RESULT_FAILED,
  NGFX_RESULT_PARAM_ERROR,
  NGFX_RESULT_DEVICE_NOT_FOUND,
} ngfxResult;

// graphics backend type
typedef enum ngfxBackend
{
  NGFX_BACKEND_VULKAN,
  NGFX_BACKEND_METAL,
  NGFX_BACKEND_D3D_11,
  NGFX_BACKEND_D3D_12,
  NGFX_BACKEND_D3D_12_SM6,
  NGFX_BACKEND_OPENGL_CORE,
  NGFX_BACKEND_OPENGL_ES_3,
} ngfxBackend;

typedef enum ngfxPipelineType
{
  NGFX_PIPELINE_TYPE_GRAPHICS,
  NGFX_PIPELINE_TYPE_COMPUTE,
} ngfxPipelineType;

// Pixel format in storage
typedef enum ngfxPixelFormat
{
  NGFX_PIXEL_FORMAT_RGBA16UINT,
  NGFX_PIXEL_FORMAT_RGBA32FLOAT,
  NGFX_PIXEL_FORMAT_RGBA8UNORM,
  NGFX_PIXEL_FORMAT_RGBA8UNORM_SRGB,
  NGFX_PIXEL_FORMAT_R11G11B10FLOAT,
  NGFX_PIXEL_FORMAT_D32FLOAT,
  NGFX_PIXEL_FORMAT_RGB32FLOAT,
} ngfxPixelFormat;

typedef enum ngfxMultiSampleFlag
{
  NGFX_MULTISAMPLE_FLAG_MS_1X,
  NGFX_MULTISAMPLE_FLAG_MS_2X,
  NGFX_MULTISAMPLE_FLAG_MS_4X,
  NGFX_MULTISAMPLE_FLAG_MS_8X,
  NGFX_MULTISAMPLE_FLAG_MS_16X,
} ngfxMultiSampleFlag;

typedef enum ngfxLoadAction
{
  NGFX_LOAD_ACTION_LOAD,
  NGFX_LOAD_ACTION_CLEAR,
  NGFX_LOAD_ACTION_DONT_CARE,
} ngfxLoadAction;

typedef enum ngfxStoreAction
{
  NGFX_STORE_ACTION_STORE,
  NGFX_STORE_ACTION_DONT_CARE,
} ngfxStoreAction;

typedef enum ngfxVertexFormat
{
  NGFX_VERTEX_FORMAT_F32C,
  NGFX_VERTEX_FORMAT_F32C2,
  NGFX_VERTEX_FORMAT_F32C3,
  NGFX_VERTEX_FORMAT_F32C4,
} ngfxVertexFormat;

typedef enum ngfxIndexBufferType
{
  NGFX_INDEX_BUFFER_TYPE_U16,
  NGFX_INDEX_BUFFER_TYPE_U32,
} ngfxIndexBufferType;

typedef enum ngfxStencilFaceRef
{
  NGFX_STENCIL_FACE_REF_FRONT,
  NGFX_STENCIL_FACE_REF_BACK,
  NGFX_STENCIL_FACE_REF_FRONT_AND_BACK,
} ngfxStencilFaceRef;

typedef enum ngfxPrimitiveType
{
  NGFX_PRIMITIVE_TYPE_POINTS,
  NGFX_PRIMITIVE_TYPE_LINES,
  NGFX_PRIMITIVE_TYPE_LINE_STRIP,
  NGFX_PRIMITIVE_TYPE_TRIANGLES,
  NGFX_PRIMITIVE_TYPE_TRIANGLESTRIPS,
} ngfxPrimitiveType;

typedef enum ngfxBlendOperation
{
  NGFX_BLEND_OPERATION_ADD,
  NGFX_BLEND_OPERATION_SUB,
  NGFX_BLEND_OPERATION_REVERSE_SUBSTRACT,
  NGFX_BLEND_OPERATION_MIN,
  NGFX_BLEND_OPERATION_MAX,
} ngfxBlendOperation;

// Color blending
typedef enum ngfxBlendFactor
{
  NGFX_BLEND_FACTOR_ZERO,
  NGFX_BLEND_FACTOR_ONE,
  NGFX_BLEND_FACTOR_SRC_COLOR,
  NGFX_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
  NGFX_BLEND_FACTOR_SRC_ALPHA,
  NGFX_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
  NGFX_BLEND_FACTOR_DST_COLOR,
  NGFX_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
  NGFX_BLEND_FACTOR_DST_ALPHA,
  NGFX_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
} ngfxBlendFactor;

// Stencil Operations
typedef enum ngfxStencilOperation
{
  NGFX_STENCIL_OPERATION_KEEP,
  NGFX_STENCIL_OPERATION_ZERO,
  NGFX_STENCIL_OPERATION_REPLACE,
  NGFX_STENCIL_OPERATION_INCREMENT_CLAMP,
  NGFX_STENCIL_OPERATION_DECREMENT_CLAMP,
  NGFX_STENCIL_OPERATION_INVERT,
  NGFX_STENCIL_OPERATION_INCREMENT_WRAP,
  NGFX_STENCIL_OPERATION_DECREMENT_WRAP,
} ngfxStencilOperation;

// Depth Comparison Functions
typedef enum ngfxComparisonFunction
{
  NGFX_COMPARISON_FUNCTION_NEVER,
  NGFX_COMPARISON_FUNCTION_LESS,
  NGFX_COMPARISON_FUNCTION_EQUAL,
  NGFX_COMPARISON_FUNCTION_LESS_EQUAL,
  NGFX_COMPARISON_FUNCTION_GREATER,
  NGFX_COMPARISON_FUNCTION_NOT_EQUAL,
  NGFX_COMPARISON_FUNCTION_GREATER_EQUAL,
  NGFX_COMPARISON_FUNCTION_ALWAYS,
} ngfxComparisonFunction;

typedef enum ngfxDepthWriteMask
{
  NGFX_DEPTH_WRITE_MASK_ZERO,
  NGFX_DEPTH_WRITE_MASK_ALL,
} ngfxDepthWriteMask;

typedef enum ngfxResourceState
{
  NGFX_RESOURCE_STATE_COMMON = 1,
  NGFX_RESOURCE_STATE_VERTEX_BUFFER = 2,
  NGFX_RESOURCE_STATE_CONSTANT_BUFFER = 4,
  NGFX_RESOURCE_STATE_FRAME_BUFFER = 8,
  NGFX_RESOURCE_STATE_PIXEL_SHADER_RESOURCE = 16,
  NGFX_RESOURCE_STATE_TRANSFER_SOURCE = 32,
  NGFX_RESOURCE_STATE_TRANSFER_DEST = 64,
  NGFX_RESOURCE_STATE_PRESENT = 128,
  NGFX_RESOURCE_STATE_GENERIC_READ = 256,
  NGFX_RESOURCE_STATE_UNORDER_ACCESS = 512,
} ngfxResourceState;

typedef enum ngfxResourceViewType
{
  NGFX_RESOURCE_VIEW_TYPE_LINEAR_BUFFER,
  NGFX_RESOURCE_VIEW_TYPE_SAMPLED_TEXTURE,
  NGFX_RESOURCE_VIEW_TYPE_UNORDER_ACCESS_TEXTURE,
  NGFX_RESOURCE_VIEW_TYPE_UNORDER_ACCESS_BUFFER,
} ngfxResourceViewType;

typedef enum ngfxBufferViewBit
{
  NGFX_BUFFER_VIEW_BIT_UNORDERED_ACCESS = 1,
  NGFX_BUFFER_VIEW_BIT_SHADER_RESOURCE = 2,
  NGFX_BUFFER_VIEW_BIT_CONSTANT_BUFFER = 4,
  NGFX_BUFFER_VIEW_BIT_VERTEX_BUFFER = 8,
  NGFX_BUFFER_VIEW_BIT_INDEX_BUFFER = 16,
  NGFX_BUFFER_VIEW_BIT_INDIRECT_BUFFER = 32,
} ngfxBufferViewBit;

typedef enum ngfxTextureViewBit
{
  NGFX_TEXTURE_VIEW_BIT_SHADER_READ = 1,
  NGFX_TEXTURE_VIEW_BIT_SHADER_WRITE = 2,
  NGFX_TEXTURE_VIEW_BIT_RENDER_TARGET = 4,
  NGFX_TEXTURE_VIEW_BIT_DEPTH_STENCIL = 8,
} ngfxTextureViewBit;

typedef enum ngfxStorageOption
{
  NGFX_STORAGE_OPTION_SHARED,
  NGFX_STORAGE_OPTION_PRIVATE,
  NGFX_STORAGE_OPTION_MANAGED,
} ngfxStorageOption;

// Dimension Of Texture
typedef enum ngfxTextureDimension
{
  NGFX_TEXTURE_DIMENSION_TEX1D,
  NGFX_TEXTURE_DIMENSION_TEX2D,
  NGFX_TEXTURE_DIMENSION_TEX2D_MS,
  NGFX_TEXTURE_DIMENSION_TEX2D_ARRAY,
  NGFX_TEXTURE_DIMENSION_TEX3D,
  NGFX_TEXTURE_DIMENSION_TEX3D_ARRAY,
  NGFX_TEXTURE_DIMENSION_TEXCUBE,
  NGFX_TEXTURE_DIMENSION_BUFFER,
} ngfxTextureDimension;

typedef enum ngfxFillMode
{
  NGFX_FILL_MODE_WIRE,
  NGFX_FILL_MODE_SOLID,
} ngfxFillMode;

typedef enum ngfxCullMode
{
  NGFX_CULL_MODE_NONE,
  NGFX_CULL_MODE_FRONT,
  NGFX_CULL_MODE_BACK,
} ngfxCullMode;

typedef enum ngfxLogicOperation
{
  NGFX_LOGIC_OPERATION_CLEAR,
  NGFX_LOGIC_OPERATION_AND,
  NGFX_LOGIC_OPERATION_XOR,
  NGFX_LOGIC_OPERATION_OR,
  NGFX_LOGIC_OPERATION_NOR,
  NGFX_LOGIC_OPERATION_INVERT,
} ngfxLogicOperation;

typedef enum ngfxFilterMode
{
  NGFX_FILTER_MODE_POINT,
  NGFX_FILTER_MODE_LINEAR,
} ngfxFilterMode;

typedef enum ngfxAddressMode
{
  NGFX_ADDRESS_MODE_WRAP,
  NGFX_ADDRESS_MODE_MIRROR,
  NGFX_ADDRESS_MODE_CLAMP,
  NGFX_ADDRESS_MODE_BORDER,
  NGFX_ADDRESS_MODE_MIRROR_ONCE,
} ngfxAddressMode;

typedef enum ngfxVertexInputRate
{
  NGFX_VERTEX_INPUT_RATE_PERVERTEX,
  NGFX_VERTEX_INPUT_RATE_PERINSTANCE,
} ngfxVertexInputRate;

typedef enum ngfxBindingType
{
  NGFX_BINDING_TYPE_UNIFORM_BUFFER,
  NGFX_BINDING_TYPE_SAMPLER,
  NGFX_BINDING_TYPE_SAMPLED_IMAGE,
  NGFX_BINDING_TYPE_STORAGE_BUFFER,
} ngfxBindingType;

typedef enum ngfxShaderStageBit
{
  NGFX_SHADER_STAGE_BIT_VERTEX = 1,
  NGFX_SHADER_STAGE_BIT_FRAGMENT = 2,
  NGFX_SHADER_STAGE_BIT_COMPUTE = 4,
  NGFX_SHADER_STAGE_BIT_GEOMETRY = 8,
  NGFX_SHADER_STAGE_BIT_TESSAILATIONEVAL = 16,
  NGFX_SHADER_STAGE_BIT_TESSAILATIONCONTROL = 32,
} ngfxShaderStageBit;

typedef enum ngfxShaderFormat
{
  NGFX_SHADER_FORMAT_TEXT,
  NGFX_SHADER_FORMAT_BYTE_CODE,
} ngfxShaderFormat;

typedef enum ngfxShaderLang
{
  NGFX_SHADER_LANG_HLSL,
  NGFX_SHADER_LANG_METALSL,
  NGFX_SHADER_LANG_GLSL,
} ngfxShaderLang;

typedef enum ngfxShaderProfile
{
  NGFX_SHADER_PROFILE_SM4,
  NGFX_SHADER_PROFILE_SM5,
  NGFX_SHADER_PROFILE_SM6,
} ngfxShaderProfile;

typedef enum ngfxShaderDataType
{
  NGFX_SHADER_DATA_TYPE_BOOL,
  NGFX_SHADER_DATA_TYPE_BOOL2,
  NGFX_SHADER_DATA_TYPE_BOOL3,
  NGFX_SHADER_DATA_TYPE_BOOL4,
  NGFX_SHADER_DATA_TYPE_INT,
  NGFX_SHADER_DATA_TYPE_INT2,
  NGFX_SHADER_DATA_TYPE_INT3,
  NGFX_SHADER_DATA_TYPE_INT4,
  NGFX_SHADER_DATA_TYPE_UINT,
  NGFX_SHADER_DATA_TYPE_UINT2,
  NGFX_SHADER_DATA_TYPE_UINT3,
  NGFX_SHADER_DATA_TYPE_UINT4,
  NGFX_SHADER_DATA_TYPE_FLOAT,
  NGFX_SHADER_DATA_TYPE_FLOAT2,
  NGFX_SHADER_DATA_TYPE_FLOAT3,
  NGFX_SHADER_DATA_TYPE_FLOAT4,
  NGFX_SHADER_DATA_TYPE_MAT2,
  NGFX_SHADER_DATA_TYPE_MAT2X3,
  NGFX_SHADER_DATA_TYPE_MAT2X4,
  NGFX_SHADER_DATA_TYPE_MAT3X2,
  NGFX_SHADER_DATA_TYPE_MAT3,
  NGFX_SHADER_DATA_TYPE_MAT3X4,
  NGFX_SHADER_DATA_TYPE_MAT4X2,
  NGFX_SHADER_DATA_TYPE_MAT4,
  NGFX_SHADER_DATA_TYPE_UNKNOWN,
} ngfxShaderDataType;

typedef enum ngfxShaderBindType
{
  NGFX_SHADER_BIND_TYPE_UNDEFINED,
  NGFX_SHADER_BIND_TYPE_BLOCK,
  NGFX_SHADER_BIND_TYPE_SAMPLER,
  NGFX_SHADER_BIND_TYPE_TEXTURE,
  NGFX_SHADER_BIND_TYPE_SAMPLER_TEXTURE,
  NGFX_SHADER_BIND_TYPE_BUFFER,
  NGFX_SHADER_BIND_TYPE_CONSTANT,
} ngfxShaderBindType;

typedef enum ngfxCommandQueueType
{
  NGFX_COMMAND_QUEUE_TYPE_GRAPHICS,
  NGFX_COMMAND_QUEUE_TYPE_COMPUTE,
  NGFX_COMMAND_QUEUE_TYPE_COPY,
} ngfxCommandQueueType;

// Type of shader
typedef enum ngfxShaderType
{
  NGFX_SHADER_TYPE_VERTEX,
  NGFX_SHADER_TYPE_FRAGMENT,
  NGFX_SHADER_TYPE_COMPUTE,
  NGFX_SHADER_TYPE_GEOMETRY,
  NGFX_SHADER_TYPE_TESSAILATIONEVAL,
  NGFX_SHADER_TYPE_TESSAILATIONCONTROL,
} ngfxShaderType;

// For shader reflection
typedef enum ngfxDataType
{
  NGFX_DATA_TYPE_NONE,
  NGFX_DATA_TYPE_STRUCT,
  NGFX_DATA_TYPE_ARRAY,
  NGFX_DATA_TYPE_POINTER,
  NGFX_DATA_TYPE_TEXTURE,
  NGFX_DATA_TYPE_SAMPLER,
  NGFX_DATA_TYPE_BOOL,
  NGFX_DATA_TYPE_BOOL2,
  NGFX_DATA_TYPE_BOOL3,
  NGFX_DATA_TYPE_BOOL4,
  NGFX_DATA_TYPE_INT,
  NGFX_DATA_TYPE_INT2,
  NGFX_DATA_TYPE_INT3,
  NGFX_DATA_TYPE_INT4,
  NGFX_DATA_TYPE_UINT,
  NGFX_DATA_TYPE_UINT2,
  NGFX_DATA_TYPE_UINT3,
  NGFX_DATA_TYPE_UINT4,
  NGFX_DATA_TYPE_FLOAT,
  NGFX_DATA_TYPE_FLOAT2,
  NGFX_DATA_TYPE_FLOAT3,
  NGFX_DATA_TYPE_FLOAT4,
  NGFX_DATA_TYPE_MAT2,
  NGFX_DATA_TYPE_MAT2X3,
  NGFX_DATA_TYPE_MAT2X4,
  NGFX_DATA_TYPE_MAT3X2,
  NGFX_DATA_TYPE_MAT3,
  NGFX_DATA_TYPE_MAT3X4,
  NGFX_DATA_TYPE_MAT4X2,
  NGFX_DATA_TYPE_MAT4,
} ngfxDataType;

typedef enum ngfxArgumentAccess
{
  NGFX_ARGUMENT_ACCESS_READ_ONLY = 1,
  NGFX_ARGUMENT_ACCESS_WRITE_ONLY = 2,
} ngfxArgumentAccess;

typedef struct _ngfxBindTableEncoder* ngfxBindTableEncoder;
typedef struct _ngfxSwapChain* ngfxSwapChain;
typedef struct _ngfxFunction* ngfxFunction;
typedef struct _ngfxLibrary* ngfxLibrary;
typedef struct _ngfxVariableType* ngfxVariableType;
typedef struct _ngfxVariable* ngfxVariable;
typedef struct _ngfxStructType* ngfxStructType;
typedef struct _ngfxArrayType* ngfxArrayType;
typedef struct _ngfxPointerType* ngfxPointerType;
typedef struct _ngfxTextureReferType* ngfxTextureReferType;
typedef struct _ngfxPipelineReflection* ngfxPipelineReflection;
typedef struct _ngfxShaderCompiler* ngfxShaderCompiler;
typedef struct _ngfxFactory* ngfxFactory;
typedef struct _ngfxFrameBuffer* ngfxFrameBuffer;
typedef struct _ngfxRenderPass* ngfxRenderPass;
typedef struct _ngfxPipeline* ngfxPipeline;
typedef struct _ngfxPipelineLibrary* ngfxPipelineLibrary;
typedef struct _ngfxComputePipeline* ngfxComputePipeline;
typedef struct _ngfxRenderPipeline* ngfxRenderPipeline;
typedef struct _ngfxPipelineLayout* ngfxPipelineLayout;
typedef struct _ngfxBindTable* ngfxBindTable;
typedef struct _ngfxSampler* ngfxSampler;
typedef struct _ngfxResource* ngfxResource;
typedef struct _ngfxBuffer* ngfxBuffer;
typedef struct _ngfxBufferView* ngfxBufferView;
typedef struct _ngfxTexture* ngfxTexture;
typedef struct _ngfxTextureView* ngfxTextureView;
typedef struct _ngfxDrawable* ngfxDrawable;
typedef struct _ngfxDevice* ngfxDevice;
typedef struct _ngfxFence* ngfxFence;
typedef struct _ngfxCommandQueue* ngfxCommandQueue;
typedef struct _ngfxCommandBuffer* ngfxCommandBuffer;
typedef struct _ngfxCommandEncoder* ngfxCommandEncoder;
typedef struct _ngfxCopyCommandEncoder* ngfxCopyCommandEncoder;
typedef struct _ngfxRenderCommandEncoder* ngfxRenderCommandEncoder;
typedef struct _ngfxComputeCommandEncoder* ngfxComputeCommandEncoder;
typedef struct _ngfxParallelRenderCommandEncoder* ngfxParallelRenderCommandEncoder;

struct ngfxDepthStencilOp
{
  ngfxStencilOperation stencilFailOp;
  ngfxStencilOperation depthStencilFailOp;
  ngfxStencilOperation stencilPassOp;
  ngfxComparisonFunction stencilFunc;
  uint32_t compareMask;
  uint32_t writeMask;
  uint32_t reference;
};

struct ngfxRasterizerState
{
  ngfxFillMode fillMode;
  ngfxCullMode cullMode;
  Bool32 frontCCW;
  Bool32 depthClipEnable;
  Float32 depthBiasClamp;
  Float32 depthBiasSlope;
  int32_t depthBias;
  Bool32 multiSampleEnable;
  uint32_t sampleCount;
  Bool32 alphaToCoverageEnable;
};

struct ngfxRtBlendState
{
  Bool32 enable;
  ngfxBlendFactor srcColorBlend;
  ngfxBlendFactor destColorBlend;
  ngfxBlendOperation colorBlendOp;
  ngfxBlendFactor srcAlphaBlend;
  ngfxBlendFactor destAlphaBlend;
  ngfxBlendOperation alphaBlendOp;
  uint32_t colorWriteMask;
};

struct ngfxBlendState
{
  Bool32 alphaToCoverageEnable;
  ngfxRtBlendState renderTargets[8];
  Bool32 logicOpEnable;
  ngfxLogicOperation logicOp;
};

struct ngfxDepthStencilState
{
  Bool32 depthEnable;
  ngfxDepthWriteMask depthWriteMask;
  ngfxComparisonFunction depthFunc;
  Bool32 stencilEnable;
  ngfxDepthStencilOp frontFace;
  ngfxDepthStencilOp backFace;
};

struct ngfxDeviceDesc
{
  uint64_t maxAllocation;
  char * vendorName;
};

struct ngfxFilter
{
  ngfxFilterMode minFilter;
  ngfxFilterMode magFilter;
  ngfxFilterMode mipMapFilter;
};

// Description of sampler
struct ngfxSamplerDesc
{
  ngfxFilter filter;
  ngfxAddressMode U,V,W;
  Float32 mipLodBias;
  uint32_t maxAnistropy;
  ngfxComparisonFunction comparisonFunc;
  Float32 minLod;
  Float32 maxLod;
};

// Description of a buffer
struct ngfxBufferDesc
{
  ngfxBufferViewBit allowedViewBits;
  ngfxStorageOption option;
  uint64_t size;
  uint64_t deviceMask;
};

// Description of the buffer usage
struct ngfxBufferViewDesc
{
  ngfxResourceViewType view;
  ngfxResourceState state;
  uint64_t size;
  uint64_t offset;
  uint64_t stride;
};

// Description of a texture
struct ngfxTextureDesc
{
  ngfxTextureViewBit allowedViewBits;
  ngfxStorageOption option;
  ngfxMultiSampleFlag samples;
  ngfxPixelFormat format;
  uint32_t width;
  uint32_t height;
  uint32_t depth;
  uint32_t layers;
  uint32_t mipLevels;
  uint64_t deviceMask;
};

// Description about how the texture be used
struct ngfxTextureViewDesc
{
  ngfxResourceViewType view;
  ngfxResourceState state;
  ngfxTextureDimension dimension;
  uint32_t mipLevel;
};

struct ngfxVertexLayout
{
  ngfxVertexInputRate rate;
  uint32_t stride;
};

struct ngfxVertexAttribute
{
  ngfxVertexFormat format;
  uint32_t offset;
  uint32_t slot;
};

// Vertex input description
struct ngfxVertexInputState
{
  const ngfxVertexAttribute * pAttributes;
  uint32_t attributeCount;
  const ngfxVertexLayout * pLayouts;
  uint32_t layoutCount;
};

// Description of rendering pipeline
struct ngfxRenderPipelineDesc
{
  ngfxRasterizerState rasterState;
  ngfxBlendState blendState;
  ngfxDepthStencilState depthStencil;
  ngfxVertexInputState inputState;
  uint32_t numRenderTargets;
  ngfxPixelFormat renderTargetFormats[8];
  ngfxPixelFormat depthStencilFormat;
  ngfxPrimitiveType primitiveTopology;
  ngfxFunction * vertexFunction;
  ngfxFunction * pixelFunction;
  uint64_t deviceMask;
};

struct ngfxShaderBinding
{
  const char * name;
  ngfxShaderStageBit visibility;
  ngfxBindingType bindingType;
  uint32_t slot;
  uint32_t count;
};

// Description of Pipeline Layout (How to layout bindings)
struct ngfxPipelineLayoutDesc
{
  const ngfxBindTableEncoder * pTableEncoders;
  uint32_t shaderLayoutCount;
};

struct ngfxAttachmentDesc
{
  ngfxLoadAction loadAction;
  ngfxStoreAction storeAction;
  ngfxTexture * texture;
};

struct ngfxColorAttachmentDesc
{
  ngfxLoadAction loadAction;
  ngfxStoreAction storeAction;
  ngfxTexture * texture;
  Float32x4 clearColor;
};

struct ngfxDepthStencilAttachmentDesc
{
  ngfxLoadAction loadAction;
  ngfxStoreAction storeAction;
  ngfxTexture * texture;
  Float32 clearDepth;
  int32_t clearStencil;
};

// Description of Render Pass
struct ngfxRenderPassDesc
{
  ngfxColorAttachmentDesc * pColorAttachments;
  int32_t colorAttachmentsCount;
  ngfxDepthStencilAttachmentDesc * pDepthStencilAttachment;
};

// Description of frame buffer
struct ngfxFrameBufferDesc
{
  ngfxTexture * colorAttachments[8];
  ngfxTexture * depthStencilAttachment;
  uint32_t layers;
};

struct ngfxDrawIndexedInstancedDesc
{
  uint32_t indexCountPerInstance;
  uint32_t instanceCount;
  uint32_t startId;
  uint32_t baseVertexId;
  uint32_t startInstanceId;
};

struct ngfxDrawInstancedDesc
{
  uint32_t vertexCountPerInstance;
  uint32_t instanceCount;
  uint32_t startVertexId;
  uint32_t startInstanceId;
};

struct ngfxViewport
{
  Float32 left, top;
  Float32 width, height;
  Float32 minDepth;
  Float32 maxDepth;
};

struct ngfxSwapChainDesc
{
  ngfxPixelFormat pixelFormat;
  uint32_t width;
  uint32_t height;
  uint32_t numColorBuffers;
  Bool32 hasDepthStencilTarget;
  ngfxPixelFormat depthStencilFormat;
};

struct ngfxShaderOption
{
  ngfxShaderType stage;
  ngfxShaderLang language;
  const char * entryName;
  ngfxShaderProfile profile;
  ngfxShaderFormat format;
};

struct ngfxArgumentDesc
{
  ngfxDataType dataType;
  int32_t index;
  ngfxArgumentAccess access;
  int32_t arrayLength;
  ngfxTextureDimension textureDim;
  int32_t bufferAlignment;
  ngfxShaderStageBit stage;
};

struct ngfxCompileOption
{
  Bool32 stripDebugSymbols;
  Bool32 optimizeSize;
  ngfxShaderLang language;
  ngfxShaderProfile profile;
  ngfxShaderFormat format;
};

#if __cplusplus

namespace ngfx
{
template <bool ThreadSafe>
struct RefCounted
{
  RefCounted() {}
  virtual ~RefCounted() {}
  int32_t AddInternalRef()
  {
    return atomic_increment(&m_IntRef);
  }
  int32_t ReleaseInternal()
  {
    auto c =atomic_decrement(&m_IntRef);
    if (m_IntRef == 0)
    {
      delete this;
    }
    return c;
  }
  int32_t Release()
  {
    auto c =atomic_decrement(&m_ExtRef);
    if (m_ExtRef == 0)
    {
      ReleaseInternal();
    }
    return c;
  }
  int32_t AddRef()
  {
    return atomic_increment(&m_ExtRef);
  }
private:
  int32_t m_IntRef = 1;
  int32_t m_ExtRef = 1;
};
/* Unthread-safe RefCounted*/
template <>
struct RefCounted<false>
{
  RefCounted() {}
  virtual ~RefCounted() {}
  int32_t AddInternalRef()
  {
    m_IntRef++;
    return m_IntRef;
  }
  int32_t ReleaseInternal()
  {
    m_IntRef--;
    int32_t c = m_IntRef;
    if (m_IntRef == 0)
    {
      delete this;
    }
    return c;
  }
  int32_t Release()
  {
    m_ExtRef--;
    int32_t c = m_ExtRef;
    if (m_ExtRef == 0)
    {
      ReleaseInternal();
    }
    return c;
  }
  int32_t AddRef()
  {
    m_ExtRef++;
    return m_ExtRef;
  }
private:
  int32_t m_IntRef = 1;
  int32_t m_ExtRef = 1;
};
template <bool ThreadSafe>
struct NamedObject : public RefCounted<ThreadSafe>
{
  virtual void SetName(const char *) {}
protected:
  void operator delete (void * Ptr)
  {
    k3d_free(Ptr, 0);
  }
};
template <class NGFXObj>
class Ptr
{
public:
  explicit Ptr(NGFXObj * pObj)
    : m_Ptr(pObj)
  {}
  Ptr(Ptr<NGFXObj> const& Other)
    : m_Ptr(Other.m_Ptr)
  {
    if(m_Ptr)
      m_Ptr->AddInternalRef();
  }
  Ptr()
    : m_Ptr(nullptr)
  {
  }
  ~Ptr()
  {
    if (m_Ptr)
    {
      m_Ptr->ReleaseInternal();
    }
    m_Ptr = nullptr;
  }
  NGFXObj& operator*() const { return *m_Ptr; }
  NGFXObj* operator->() const { return m_Ptr; }
  explicit operator bool() const
  {
    return m_Ptr != nullptr;
  }
  void Swap(Ptr& Other)
  {
    NGFXObj * const pValue = Other.m_Ptr;
    Other.m_Ptr = m_Ptr;
    m_Ptr = pValue;
  }
  Ptr& operator=(const Ptr& Other)
  {
    typedef Ptr<NGFXObj> ThisType;
    if (&Other != this)
    {
      ThisType(Other).Swap(*this);
    }
    return *this;
  }
  NGFXObj* Get() const
  {
    return m_Ptr;
  }
  NGFXObj** GetAddressOf()
  {
    return &m_Ptr;
  }
private:
  NGFXObj* m_Ptr;
};

struct Handle
{
    void* ptr;
};
class Object
{
public:
    inline void* GetAPIObject() { return m_ptr; }

    virtual ~Object();
protected:
    void* m_ptr = nullptr;
};

template <typename TEnum>
class EnumAsUint32
{
public:
  static_assert(__is_enum(TEnum), "TEnum is enum!");
  EnumAsUint32(uint32_t Val = 0) : Value(Val) {}
  EnumAsUint32(TEnum eVal) : Value(static_cast<uint32_t>(eVal)) {}
  void operator |= (const TEnum& rhs)
  {
    Value |= static_cast<uint32_t>(rhs);
  }
  void operator &= (const TEnum& rhs)
  {
    Value &= static_cast<uint32_t>(rhs);
  }
  void operator ^= (const TEnum& rhs)
  {
    Value ^= static_cast<uint32_t>(rhs);
  }
  EnumAsUint32<TEnum> operator ~()
  {
    return EnumAsUint32<TEnum>(~Value);
  }
  operator TEnum() const
  {
      return static_cast<TEnum>(Value);
  }
  uint32_t Value;
};

template <typename TEnum>
inline bool operator == (const EnumAsUint32<TEnum>& Lhs, TEnum const& Rhs)
{
    return Lhs.Value == static_cast<uint32_t>(Rhs);
}

template <typename TEnum>
inline bool operator & (const EnumAsUint32<TEnum>& Lhs, const TEnum& Rhs)
{
  return Lhs.Value & static_cast<uint32_t>(Rhs);
}

// Result of every call
enum class Result : uint32_t
{
  Ok,
  Failed,
  ParamError,
  DeviceNotFound,
};// Enum Result

// graphics backend type
enum class Backend : uint32_t
{
  Vulkan,
  Metal,
  D3D11,
  D3D12,
  D3D12SM6,
  OpenGLCore,
  OpenGLES3,
};// Enum Backend

enum class PipelineType : uint32_t
{
  Graphics,
  Compute,
};// Enum PipelineType

// Pixel format in storage
enum class PixelFormat : uint32_t
{
  RGBA16Uint,
  RGBA32Float,
  RGBA8UNorm,
  RGBA8UNorm_sRGB,
  R11G11B10Float,
  D32Float,
  RGB32Float,
};// Enum PixelFormat

enum class MultiSampleFlag : uint32_t
{
  MS1x,
  MS2x,
  MS4x,
  MS8x,
  MS16x,
};// Enum MultiSampleFlag

enum class LoadAction : uint32_t
{
  Load,
  Clear,
  DontCare,
};// Enum LoadAction

enum class StoreAction : uint32_t
{
  Store,
  DontCare,
};// Enum StoreAction

enum class VertexFormat : uint32_t
{
  F32C,
  F32C2,
  F32C3,
  F32C4,
};// Enum VertexFormat

enum class IndexBufferType : uint32_t
{
  U16,
  U32,
};// Enum IndexBufferType

enum class StencilFaceRef : uint32_t
{
  Front,
  Back,
  FrontAndBack,
};// Enum StencilFaceRef

enum class PrimitiveType : uint32_t
{
  Points,
  Lines,
  LineStrip,
  Triangles,
  TriangleStrips,
};// Enum PrimitiveType

enum class BlendOperation : uint32_t
{
  Add,
  Sub,
  ReverseSubstract,
  Min,
  Max,
};// Enum BlendOperation

// Color blending
enum class BlendFactor : uint32_t
{
  Zero,
  One,
  SrcColor,
  OneMinusSrcColor,
  SrcAlpha,
  OneMinusSrcAlpha,
  DstColor,
  OneMinusDstColor,
  DstAlpha,
  OneMinusDstAlpha,
};// Enum BlendFactor

// Stencil Operations
enum class StencilOperation : uint32_t
{
  Keep,
  Zero,
  Replace,
  IncrementClamp,
  DecrementClamp,
  Invert,
  IncrementWrap,
  DecrementWrap,
};// Enum StencilOperation

// Depth Comparison Functions
enum class ComparisonFunction : uint32_t
{
  Never,
  Less,
  Equal,
  LessEqual,
  Greater,
  NotEqual,
  GreaterEqual,
  Always,
};// Enum ComparisonFunction

enum class DepthWriteMask : uint32_t
{
  Zero,
  All,
};// Enum DepthWriteMask

enum class ResourceState : uint32_t
{
  Common = 1,
  VertexBuffer = 2,
  ConstantBuffer = 4,
  FrameBuffer = 8,
  PixelShaderResource = 16,
  TransferSource = 32,
  TransferDest = 64,
  Present = 128,
  GenericRead = 256,
  UnorderAccess = 512,
};// Enum ResourceState

enum class ResourceViewType : uint32_t
{
  LinearBuffer,
  SampledTexture,
  UnorderAccessTexture,
  UnorderAccessBuffer,
};// Enum ResourceViewType

enum class BufferViewBit : uint32_t
{
  UnOrderedAccess = 1,
  ShaderResource = 2,
  ConstantBuffer = 4,
  VertexBuffer = 8,
  IndexBuffer = 16,
  IndirectBuffer = 32,
};// Enum BufferViewBit

enum class TextureViewBit : uint32_t
{
  ShaderRead = 1,
  ShaderWrite = 2,
  RenderTarget = 4,
  DepthStencil = 8,
};// Enum TextureViewBit

enum class StorageOption : uint32_t
{
  Shared,
  Private,
  Managed,
};// Enum StorageOption

// Dimension Of Texture
enum class TextureDimension : uint32_t
{
  Tex1D,
  Tex2D,
  Tex2DMS,
  Tex2DArray,
  Tex3D,
  Tex3DArray,
  TexCube,
  Buffer,
};// Enum TextureDimension

enum class FillMode : uint32_t
{
  Wire,
  Solid,
};// Enum FillMode

enum class CullMode : uint32_t
{
  None,
  Front,
  Back,
};// Enum CullMode

enum class LogicOperation : uint32_t
{
  Clear,
  And,
  Xor,
  Or,
  Nor,
  Invert,
};// Enum LogicOperation

enum class FilterMode : uint32_t
{
  Point,
  Linear,
};// Enum FilterMode

enum class AddressMode : uint32_t
{
  Wrap,
  Mirror,
  Clamp,
  Border,
  MirrorOnce,
};// Enum AddressMode

enum class VertexInputRate : uint32_t
{
  PerVertex,
  PerInstance,
};// Enum VertexInputRate

enum class BindingType : uint32_t
{
  UniformBuffer,
  Sampler,
  SampledImage,
  StorageBuffer,
};// Enum BindingType

enum class ShaderStageBit : uint32_t
{
  Vertex = 1,
  Fragment = 2,
  Compute = 4,
  Geometry = 8,
  TessailationEval = 16,
  TessailationControl = 32,
};// Enum ShaderStageBit

enum class ShaderFormat : uint32_t
{
  Text,
  ByteCode,
};// Enum ShaderFormat

enum class ShaderLang : uint32_t
{
  HLSL,
  MetalSL,
  GLSL,
};// Enum ShaderLang

enum class ShaderProfile : uint32_t
{
  SM4,
  SM5,
  SM6,
};// Enum ShaderProfile

enum class ShaderDataType : uint32_t
{
  Bool,
  Bool2,
  Bool3,
  Bool4,
  Int,
  Int2,
  Int3,
  Int4,
  UInt,
  UInt2,
  UInt3,
  UInt4,
  Float,
  Float2,
  Float3,
  Float4,
  Mat2,
  Mat2x3,
  Mat2x4,
  Mat3x2,
  Mat3,
  Mat3x4,
  Mat4x2,
  Mat4,
  Unknown,
};// Enum ShaderDataType

enum class ShaderBindType : uint32_t
{
  Undefined,
  Block,
  Sampler,
  Texture,
  SamplerTexture,
  Buffer,
  Constant,
};// Enum ShaderBindType

enum class CommandQueueType : uint32_t
{
  Graphics,
  Compute,
  Copy,
};// Enum CommandQueueType

// Type of shader
enum class ShaderType : uint32_t
{
  Vertex,
  Fragment,
  Compute,
  Geometry,
  TessailationEval,
  TessailationControl,
};// Enum ShaderType

// For shader reflection
enum class DataType : uint32_t
{
  None,
  Struct,
  Array,
  Pointer,
  Texture,
  Sampler,
  Bool,
  Bool2,
  Bool3,
  Bool4,
  Int,
  Int2,
  Int3,
  Int4,
  Uint,
  Uint2,
  Uint3,
  Uint4,
  Float,
  Float2,
  Float3,
  Float4,
  Mat2,
  Mat2x3,
  Mat2x4,
  Mat3x2,
  Mat3,
  Mat3x4,
  Mat4x2,
  Mat4,
};// Enum DataType

enum class ArgumentAccess : uint32_t
{
  ReadOnly = 1,
  WriteOnly = 2,
};// Enum ArgumentAccess

struct BindTableEncoder;
struct SwapChain;
struct Function;
struct Library;
struct VariableType;
struct Variable;
struct StructType;
struct ArrayType;
struct PointerType;
struct TextureReferType;
struct PipelineReflection;
struct ShaderCompiler;
struct Factory;
struct FrameBuffer;
struct RenderPass;
struct Pipeline;
struct PipelineLibrary;
struct ComputePipeline;
struct RenderPipeline;
struct PipelineLayout;
struct BindTable;
struct Sampler;
struct Resource;
struct Buffer;
struct BufferView;
struct Texture;
struct TextureView;
struct Drawable;
struct Device;
struct Fence;
struct CommandQueue;
struct CommandBuffer;
struct CommandEncoder;
struct CopyCommandEncoder;
struct RenderCommandEncoder;
struct ComputeCommandEncoder;
struct ParallelRenderCommandEncoder;

struct DepthStencilOp
{
  StencilOperation stencilFailOp;
  StencilOperation depthStencilFailOp;
  StencilOperation stencilPassOp;
  ComparisonFunction stencilFunc;
  uint32_t compareMask;
  uint32_t writeMask;
  uint32_t reference;

  DepthStencilOp(StencilOperation _stencilFailOp = StencilOperation::Keep, StencilOperation _depthStencilFailOp = StencilOperation::Keep, StencilOperation _stencilPassOp = StencilOperation::Keep, ComparisonFunction _stencilFunc = ComparisonFunction::Never, uint32_t _compareMask = 0, uint32_t _writeMask = 0, uint32_t _reference = 0)
  : stencilFailOp(_stencilFailOp)
  , depthStencilFailOp(_depthStencilFailOp)
  , stencilPassOp(_stencilPassOp)
  , stencilFunc(_stencilFunc)
  , compareMask(_compareMask)
  , writeMask(_writeMask)
  , reference(_reference)
  {  }

  DepthStencilOp& SetStencilFailOp(StencilOperation _stencilFailOp)
  {
    stencilFailOp = _stencilFailOp;
    return *this;
  }

  DepthStencilOp& SetDepthStencilFailOp(StencilOperation _depthStencilFailOp)
  {
    depthStencilFailOp = _depthStencilFailOp;
    return *this;
  }

  DepthStencilOp& SetStencilPassOp(StencilOperation _stencilPassOp)
  {
    stencilPassOp = _stencilPassOp;
    return *this;
  }

  DepthStencilOp& SetStencilFunc(ComparisonFunction _stencilFunc)
  {
    stencilFunc = _stencilFunc;
    return *this;
  }

  DepthStencilOp& SetCompareMask(uint32_t _compareMask)
  {
    compareMask = _compareMask;
    return *this;
  }

  DepthStencilOp& SetWriteMask(uint32_t _writeMask)
  {
    writeMask = _writeMask;
    return *this;
  }

  DepthStencilOp& SetReference(uint32_t _reference)
  {
    reference = _reference;
    return *this;
  }
};

static_assert(sizeof(DepthStencilOp) == sizeof(ngfxDepthStencilOp), "DepthStencilOp & ngfxDepthStencilOp Size Not Equal!");

struct RasterizerState
{
  FillMode fillMode;
  CullMode cullMode;
  Bool32 frontCCW;
  Bool32 depthClipEnable;
  Float32 depthBiasClamp;
  Float32 depthBiasSlope;
  int32_t depthBias;
  Bool32 multiSampleEnable;
  uint32_t sampleCount;
  Bool32 alphaToCoverageEnable;

  RasterizerState(FillMode _fillMode = FillMode::Wire, CullMode _cullMode = CullMode::None, Bool32 _frontCCW = 0, Bool32 _depthClipEnable = 0, Float32 _depthBiasClamp = 0, Float32 _depthBiasSlope = 0, int32_t _depthBias = 0, Bool32 _multiSampleEnable = 0, uint32_t _sampleCount = 0, Bool32 _alphaToCoverageEnable = 0)
  : fillMode(_fillMode)
  , cullMode(_cullMode)
  , frontCCW(_frontCCW)
  , depthClipEnable(_depthClipEnable)
  , depthBiasClamp(_depthBiasClamp)
  , depthBiasSlope(_depthBiasSlope)
  , depthBias(_depthBias)
  , multiSampleEnable(_multiSampleEnable)
  , sampleCount(_sampleCount)
  , alphaToCoverageEnable(_alphaToCoverageEnable)
  {  }

  RasterizerState& SetFillMode(FillMode _fillMode)
  {
    fillMode = _fillMode;
    return *this;
  }

  RasterizerState& SetCullMode(CullMode _cullMode)
  {
    cullMode = _cullMode;
    return *this;
  }

  RasterizerState& SetFrontCCW(Bool32 _frontCCW)
  {
    frontCCW = _frontCCW;
    return *this;
  }

  RasterizerState& SetDepthClipEnable(Bool32 _depthClipEnable)
  {
    depthClipEnable = _depthClipEnable;
    return *this;
  }

  RasterizerState& SetDepthBiasClamp(Float32 _depthBiasClamp)
  {
    depthBiasClamp = _depthBiasClamp;
    return *this;
  }

  RasterizerState& SetDepthBiasSlope(Float32 _depthBiasSlope)
  {
    depthBiasSlope = _depthBiasSlope;
    return *this;
  }

  RasterizerState& SetDepthBias(int32_t _depthBias)
  {
    depthBias = _depthBias;
    return *this;
  }

  RasterizerState& SetMultiSampleEnable(Bool32 _multiSampleEnable)
  {
    multiSampleEnable = _multiSampleEnable;
    return *this;
  }

  RasterizerState& SetSampleCount(uint32_t _sampleCount)
  {
    sampleCount = _sampleCount;
    return *this;
  }

  RasterizerState& SetAlphaToCoverageEnable(Bool32 _alphaToCoverageEnable)
  {
    alphaToCoverageEnable = _alphaToCoverageEnable;
    return *this;
  }
};

static_assert(sizeof(RasterizerState) == sizeof(ngfxRasterizerState), "RasterizerState & ngfxRasterizerState Size Not Equal!");

struct RtBlendState
{
  Bool32 enable;
  BlendFactor srcColorBlend;
  BlendFactor destColorBlend;
  BlendOperation colorBlendOp;
  BlendFactor srcAlphaBlend;
  BlendFactor destAlphaBlend;
  BlendOperation alphaBlendOp;
  uint32_t colorWriteMask;

  RtBlendState(Bool32 _enable = 0, BlendFactor _srcColorBlend = BlendFactor::Zero, BlendFactor _destColorBlend = BlendFactor::Zero, BlendOperation _colorBlendOp = BlendOperation::Add, BlendFactor _srcAlphaBlend = BlendFactor::Zero, BlendFactor _destAlphaBlend = BlendFactor::Zero, BlendOperation _alphaBlendOp = BlendOperation::Add, uint32_t _colorWriteMask = 0)
  : enable(_enable)
  , srcColorBlend(_srcColorBlend)
  , destColorBlend(_destColorBlend)
  , colorBlendOp(_colorBlendOp)
  , srcAlphaBlend(_srcAlphaBlend)
  , destAlphaBlend(_destAlphaBlend)
  , alphaBlendOp(_alphaBlendOp)
  , colorWriteMask(_colorWriteMask)
  {  }

  RtBlendState& SetEnable(Bool32 _enable)
  {
    enable = _enable;
    return *this;
  }

  RtBlendState& SetSrcColorBlend(BlendFactor _srcColorBlend)
  {
    srcColorBlend = _srcColorBlend;
    return *this;
  }

  RtBlendState& SetDestColorBlend(BlendFactor _destColorBlend)
  {
    destColorBlend = _destColorBlend;
    return *this;
  }

  RtBlendState& SetColorBlendOp(BlendOperation _colorBlendOp)
  {
    colorBlendOp = _colorBlendOp;
    return *this;
  }

  RtBlendState& SetSrcAlphaBlend(BlendFactor _srcAlphaBlend)
  {
    srcAlphaBlend = _srcAlphaBlend;
    return *this;
  }

  RtBlendState& SetDestAlphaBlend(BlendFactor _destAlphaBlend)
  {
    destAlphaBlend = _destAlphaBlend;
    return *this;
  }

  RtBlendState& SetAlphaBlendOp(BlendOperation _alphaBlendOp)
  {
    alphaBlendOp = _alphaBlendOp;
    return *this;
  }

  RtBlendState& SetColorWriteMask(uint32_t _colorWriteMask)
  {
    colorWriteMask = _colorWriteMask;
    return *this;
  }
};

static_assert(sizeof(RtBlendState) == sizeof(ngfxRtBlendState), "RtBlendState & ngfxRtBlendState Size Not Equal!");

struct BlendState
{
  Bool32 alphaToCoverageEnable;
  RtBlendState renderTargets[8];
  Bool32 logicOpEnable;
  LogicOperation logicOp;

  BlendState(Bool32 _alphaToCoverageEnable = 0, Bool32 _logicOpEnable = 0, LogicOperation _logicOp = LogicOperation::Clear)
  : alphaToCoverageEnable(_alphaToCoverageEnable)
  , logicOpEnable(_logicOpEnable)
  , logicOp(_logicOp)
  {
    memset(renderTargets, 0, sizeof(renderTargets));
  }

  BlendState& SetAlphaToCoverageEnable(Bool32 _alphaToCoverageEnable)
  {
    alphaToCoverageEnable = _alphaToCoverageEnable;
    return *this;
  }

  BlendState& SetRenderTarget(int index, RtBlendState _renderTargets)
  {
    renderTargets[index] = _renderTargets;
    return *this;
  }

  BlendState& SetLogicOpEnable(Bool32 _logicOpEnable)
  {
    logicOpEnable = _logicOpEnable;
    return *this;
  }

  BlendState& SetLogicOp(LogicOperation _logicOp)
  {
    logicOp = _logicOp;
    return *this;
  }
};

static_assert(sizeof(BlendState) == sizeof(ngfxBlendState), "BlendState & ngfxBlendState Size Not Equal!");

struct DepthStencilState
{
  Bool32 depthEnable;
  DepthWriteMask depthWriteMask;
  ComparisonFunction depthFunc;
  Bool32 stencilEnable;
  DepthStencilOp frontFace;
  DepthStencilOp backFace;

  DepthStencilState(Bool32 _depthEnable = 0, DepthWriteMask _depthWriteMask = DepthWriteMask::Zero, ComparisonFunction _depthFunc = ComparisonFunction::Never, Bool32 _stencilEnable = 0, DepthStencilOp _frontFace = DepthStencilOp(), DepthStencilOp _backFace = DepthStencilOp())
  : depthEnable(_depthEnable)
  , depthWriteMask(_depthWriteMask)
  , depthFunc(_depthFunc)
  , stencilEnable(_stencilEnable)
  , frontFace(_frontFace)
  , backFace(_backFace)
  {  }

  DepthStencilState& SetDepthEnable(Bool32 _depthEnable)
  {
    depthEnable = _depthEnable;
    return *this;
  }

  DepthStencilState& SetDepthWriteMask(DepthWriteMask _depthWriteMask)
  {
    depthWriteMask = _depthWriteMask;
    return *this;
  }

  DepthStencilState& SetDepthFunc(ComparisonFunction _depthFunc)
  {
    depthFunc = _depthFunc;
    return *this;
  }

  DepthStencilState& SetStencilEnable(Bool32 _stencilEnable)
  {
    stencilEnable = _stencilEnable;
    return *this;
  }

  DepthStencilState& SetFrontFace(DepthStencilOp _frontFace)
  {
    frontFace = _frontFace;
    return *this;
  }

  DepthStencilState& SetBackFace(DepthStencilOp _backFace)
  {
    backFace = _backFace;
    return *this;
  }
};

static_assert(sizeof(DepthStencilState) == sizeof(ngfxDepthStencilState), "DepthStencilState & ngfxDepthStencilState Size Not Equal!");

struct DeviceDesc
{
  uint64_t maxAllocation;
  char * vendorName;

  DeviceDesc(uint64_t _maxAllocation = 0, char * _vendorName = nullptr)
  : maxAllocation(_maxAllocation)
  , vendorName(_vendorName)
  {  }

  DeviceDesc& SetMaxAllocation(uint64_t _maxAllocation)
  {
    maxAllocation = _maxAllocation;
    return *this;
  }

  DeviceDesc& SetVendorName(char * _vendorName)
  {
    vendorName = _vendorName;
    return *this;
  }
};

static_assert(sizeof(DeviceDesc) == sizeof(ngfxDeviceDesc), "DeviceDesc & ngfxDeviceDesc Size Not Equal!");

struct Filter
{
  FilterMode minFilter;
  FilterMode magFilter;
  FilterMode mipMapFilter;

  Filter(FilterMode _minFilter = FilterMode::Point, FilterMode _magFilter = FilterMode::Point, FilterMode _mipMapFilter = FilterMode::Point)
  : minFilter(_minFilter)
  , magFilter(_magFilter)
  , mipMapFilter(_mipMapFilter)
  {  }

  Filter& SetMinFilter(FilterMode _minFilter)
  {
    minFilter = _minFilter;
    return *this;
  }

  Filter& SetMagFilter(FilterMode _magFilter)
  {
    magFilter = _magFilter;
    return *this;
  }

  Filter& SetMipMapFilter(FilterMode _mipMapFilter)
  {
    mipMapFilter = _mipMapFilter;
    return *this;
  }
};

static_assert(sizeof(Filter) == sizeof(ngfxFilter), "Filter & ngfxFilter Size Not Equal!");

// Description of sampler
struct SamplerDesc
{
  Filter filter;
  AddressMode U,V,W;
  Float32 mipLodBias;
  uint32_t maxAnistropy;
  ComparisonFunction comparisonFunc;
  Float32 minLod;
  Float32 maxLod;

  SamplerDesc(Filter _filter = Filter(), AddressMode _U = AddressMode::Wrap, AddressMode _V = AddressMode::Wrap, AddressMode _W = AddressMode::Wrap, Float32 _mipLodBias = 0, uint32_t _maxAnistropy = 0, ComparisonFunction _comparisonFunc = ComparisonFunction::Never, Float32 _minLod = 0, Float32 _maxLod = 0)
  : filter(_filter)
  , U(_U)
  , V(_V)
  , W(_W)
  , mipLodBias(_mipLodBias)
  , maxAnistropy(_maxAnistropy)
  , comparisonFunc(_comparisonFunc)
  , minLod(_minLod)
  , maxLod(_maxLod)
  {  }

  SamplerDesc& SetFilter(Filter _filter)
  {
    filter = _filter;
    return *this;
  }

  SamplerDesc& SetUVW(AddressMode _U, AddressMode _V, AddressMode _W)
  {
    U = _U;
    V = _V;
    W = _W;
    return *this;
  }

  SamplerDesc& SetMipLodBias(Float32 _mipLodBias)
  {
    mipLodBias = _mipLodBias;
    return *this;
  }

  SamplerDesc& SetMaxAnistropy(uint32_t _maxAnistropy)
  {
    maxAnistropy = _maxAnistropy;
    return *this;
  }

  SamplerDesc& SetComparisonFunc(ComparisonFunction _comparisonFunc)
  {
    comparisonFunc = _comparisonFunc;
    return *this;
  }

  SamplerDesc& SetMinLod(Float32 _minLod)
  {
    minLod = _minLod;
    return *this;
  }

  SamplerDesc& SetMaxLod(Float32 _maxLod)
  {
    maxLod = _maxLod;
    return *this;
  }
};

static_assert(sizeof(SamplerDesc) == sizeof(ngfxSamplerDesc), "SamplerDesc & ngfxSamplerDesc Size Not Equal!");

// Description of a buffer
struct BufferDesc
{
  EnumAsUint32<BufferViewBit> allowedViewBits;
  StorageOption option;
  uint64_t size;
  uint64_t deviceMask;

  BufferDesc(BufferViewBit _allowedViewBits = BufferViewBit::UnOrderedAccess, StorageOption _option = StorageOption::Shared, uint64_t _size = 0, uint64_t _deviceMask = 0)
  : allowedViewBits(_allowedViewBits)
  , option(_option)
  , size(_size)
  , deviceMask(_deviceMask)
  {  }

  BufferDesc& SetAllowedViewBits(BufferViewBit _allowedViewBits)
  {
    allowedViewBits = _allowedViewBits;
    return *this;
  }

  BufferDesc& SetOption(StorageOption _option)
  {
    option = _option;
    return *this;
  }

  BufferDesc& SetSize(uint64_t _size)
  {
    size = _size;
    return *this;
  }

  BufferDesc& SetDeviceMask(uint64_t _deviceMask)
  {
    deviceMask = _deviceMask;
    return *this;
  }
};

static_assert(sizeof(BufferDesc) == sizeof(ngfxBufferDesc), "BufferDesc & ngfxBufferDesc Size Not Equal!");

// Description of the buffer usage
struct BufferViewDesc
{
  ResourceViewType view;
  EnumAsUint32<ResourceState> state;
  uint64_t size;
  uint64_t offset;
  uint64_t stride;

  BufferViewDesc(ResourceViewType _view = ResourceViewType::LinearBuffer, ResourceState _state = ResourceState::Common, uint64_t _size = 0, uint64_t _offset = 0, uint64_t _stride = 0)
  : view(_view)
  , state(_state)
  , size(_size)
  , offset(_offset)
  , stride(_stride)
  {  }

  BufferViewDesc& SetView(ResourceViewType _view)
  {
    view = _view;
    return *this;
  }

  BufferViewDesc& SetState(ResourceState _state)
  {
    state = _state;
    return *this;
  }

  BufferViewDesc& SetSize(uint64_t _size)
  {
    size = _size;
    return *this;
  }

  BufferViewDesc& SetOffset(uint64_t _offset)
  {
    offset = _offset;
    return *this;
  }

  BufferViewDesc& SetStride(uint64_t _stride)
  {
    stride = _stride;
    return *this;
  }
};

static_assert(sizeof(BufferViewDesc) == sizeof(ngfxBufferViewDesc), "BufferViewDesc & ngfxBufferViewDesc Size Not Equal!");

// Description of a texture
struct TextureDesc
{
  EnumAsUint32<TextureViewBit> allowedViewBits;
  StorageOption option;
  MultiSampleFlag samples;
  PixelFormat format;
  uint32_t width;
  uint32_t height;
  uint32_t depth;
  uint32_t layers;
  uint32_t mipLevels;
  uint64_t deviceMask;

  TextureDesc(TextureViewBit _allowedViewBits = TextureViewBit::ShaderRead, StorageOption _option = StorageOption::Shared, MultiSampleFlag _samples = MultiSampleFlag::MS1x, PixelFormat _format = PixelFormat::RGBA16Uint, uint32_t _width = 0, uint32_t _height = 0, uint32_t _depth = 0, uint32_t _layers = 0, uint32_t _mipLevels = 0, uint64_t _deviceMask = 0)
  : allowedViewBits(_allowedViewBits)
  , option(_option)
  , samples(_samples)
  , format(_format)
  , width(_width)
  , height(_height)
  , depth(_depth)
  , layers(_layers)
  , mipLevels(_mipLevels)
  , deviceMask(_deviceMask)
  {  }

  TextureDesc& SetAllowedViewBits(TextureViewBit _allowedViewBits)
  {
    allowedViewBits = _allowedViewBits;
    return *this;
  }

  TextureDesc& SetOption(StorageOption _option)
  {
    option = _option;
    return *this;
  }

  TextureDesc& SetSamples(MultiSampleFlag _samples)
  {
    samples = _samples;
    return *this;
  }

  TextureDesc& SetFormat(PixelFormat _format)
  {
    format = _format;
    return *this;
  }

  TextureDesc& SetWidth(uint32_t _width)
  {
    width = _width;
    return *this;
  }

  TextureDesc& SetHeight(uint32_t _height)
  {
    height = _height;
    return *this;
  }

  TextureDesc& SetDepth(uint32_t _depth)
  {
    depth = _depth;
    return *this;
  }

  TextureDesc& SetLayers(uint32_t _layers)
  {
    layers = _layers;
    return *this;
  }

  TextureDesc& SetMipLevels(uint32_t _mipLevels)
  {
    mipLevels = _mipLevels;
    return *this;
  }

  TextureDesc& SetDeviceMask(uint64_t _deviceMask)
  {
    deviceMask = _deviceMask;
    return *this;
  }
};

static_assert(sizeof(TextureDesc) == sizeof(ngfxTextureDesc), "TextureDesc & ngfxTextureDesc Size Not Equal!");

// Description about how the texture be used
struct TextureViewDesc
{
  ResourceViewType view;
  EnumAsUint32<ResourceState> state;
  TextureDimension dimension;
  uint32_t mipLevel;

  TextureViewDesc(ResourceViewType _view = ResourceViewType::LinearBuffer, ResourceState _state = ResourceState::Common, TextureDimension _dimension = TextureDimension::Tex1D, uint32_t _mipLevel = 0)
  : view(_view)
  , state(_state)
  , dimension(_dimension)
  , mipLevel(_mipLevel)
  {  }

  TextureViewDesc& SetView(ResourceViewType _view)
  {
    view = _view;
    return *this;
  }

  TextureViewDesc& SetState(ResourceState _state)
  {
    state = _state;
    return *this;
  }

  TextureViewDesc& SetDimension(TextureDimension _dimension)
  {
    dimension = _dimension;
    return *this;
  }

  TextureViewDesc& SetMipLevel(uint32_t _mipLevel)
  {
    mipLevel = _mipLevel;
    return *this;
  }
};

static_assert(sizeof(TextureViewDesc) == sizeof(ngfxTextureViewDesc), "TextureViewDesc & ngfxTextureViewDesc Size Not Equal!");

struct VertexLayout
{
  VertexInputRate rate;
  uint32_t stride;

  VertexLayout(VertexInputRate _rate = VertexInputRate::PerVertex, uint32_t _stride = 0)
  : rate(_rate)
  , stride(_stride)
  {  }

  VertexLayout& SetRate(VertexInputRate _rate)
  {
    rate = _rate;
    return *this;
  }

  VertexLayout& SetStride(uint32_t _stride)
  {
    stride = _stride;
    return *this;
  }
};

static_assert(sizeof(VertexLayout) == sizeof(ngfxVertexLayout), "VertexLayout & ngfxVertexLayout Size Not Equal!");

struct VertexAttribute
{
  VertexFormat format;
  uint32_t offset;
  uint32_t slot;

  VertexAttribute(VertexFormat _format = VertexFormat::F32C, uint32_t _offset = 0, uint32_t _slot = 0)
  : format(_format)
  , offset(_offset)
  , slot(_slot)
  {  }

  VertexAttribute& SetFormat(VertexFormat _format)
  {
    format = _format;
    return *this;
  }

  VertexAttribute& SetOffset(uint32_t _offset)
  {
    offset = _offset;
    return *this;
  }

  VertexAttribute& SetSlot(uint32_t _slot)
  {
    slot = _slot;
    return *this;
  }
};

static_assert(sizeof(VertexAttribute) == sizeof(ngfxVertexAttribute), "VertexAttribute & ngfxVertexAttribute Size Not Equal!");

// Vertex input description
struct VertexInputState
{
  const VertexAttribute * pAttributes;
  uint32_t attributeCount;
  const VertexLayout * pLayouts;
  uint32_t layoutCount;

  VertexInputState(const VertexAttribute * _pAttributes = nullptr, uint32_t _attributeCount = 0, const VertexLayout * _pLayouts = nullptr, uint32_t _layoutCount = 0)
  : pAttributes(_pAttributes)
  , attributeCount(_attributeCount)
  , pLayouts(_pLayouts)
  , layoutCount(_layoutCount)
  {  }

  VertexInputState& SetPAttributes(const VertexAttribute * _pAttributes)
  {
    pAttributes = _pAttributes;
    return *this;
  }

  VertexInputState& SetAttributeCount(uint32_t _attributeCount)
  {
    attributeCount = _attributeCount;
    return *this;
  }

  VertexInputState& SetPLayouts(const VertexLayout * _pLayouts)
  {
    pLayouts = _pLayouts;
    return *this;
  }

  VertexInputState& SetLayoutCount(uint32_t _layoutCount)
  {
    layoutCount = _layoutCount;
    return *this;
  }
};

static_assert(sizeof(VertexInputState) == sizeof(ngfxVertexInputState), "VertexInputState & ngfxVertexInputState Size Not Equal!");

// Description of rendering pipeline
struct RenderPipelineDesc
{
  RasterizerState rasterState;
  BlendState blendState;
  DepthStencilState depthStencil;
  VertexInputState inputState;
  uint32_t numRenderTargets;
  PixelFormat renderTargetFormats[8];
  PixelFormat depthStencilFormat;
  PrimitiveType primitiveTopology;
  Function * vertexFunction;
  Function * pixelFunction;
  uint64_t deviceMask;

  RenderPipelineDesc(RasterizerState _rasterState = RasterizerState(), BlendState _blendState = BlendState(), DepthStencilState _depthStencil = DepthStencilState(), VertexInputState _inputState = VertexInputState(), uint32_t _numRenderTargets = 0, PixelFormat _depthStencilFormat = PixelFormat::RGBA16Uint, PrimitiveType _primitiveTopology = PrimitiveType::Points, Function * _vertexFunction = nullptr, Function * _pixelFunction = nullptr, uint64_t _deviceMask = 0)
  : rasterState(_rasterState)
  , blendState(_blendState)
  , depthStencil(_depthStencil)
  , inputState(_inputState)
  , numRenderTargets(_numRenderTargets)
  , depthStencilFormat(_depthStencilFormat)
  , primitiveTopology(_primitiveTopology)
  , vertexFunction(_vertexFunction)
  , pixelFunction(_pixelFunction)
  , deviceMask(_deviceMask)
  {
    memset(renderTargetFormats, 0, sizeof(renderTargetFormats));
  }

  RenderPipelineDesc& SetRasterState(RasterizerState _rasterState)
  {
    rasterState = _rasterState;
    return *this;
  }

  RenderPipelineDesc& SetBlendState(BlendState _blendState)
  {
    blendState = _blendState;
    return *this;
  }

  RenderPipelineDesc& SetDepthStencil(DepthStencilState _depthStencil)
  {
    depthStencil = _depthStencil;
    return *this;
  }

  RenderPipelineDesc& SetInputState(VertexInputState _inputState)
  {
    inputState = _inputState;
    return *this;
  }

  RenderPipelineDesc& SetNumRenderTargets(uint32_t _numRenderTargets)
  {
    numRenderTargets = _numRenderTargets;
    return *this;
  }

  RenderPipelineDesc& SetRenderTargetFormat(int index, PixelFormat _renderTargetFormats)
  {
    renderTargetFormats[index] = _renderTargetFormats;
    return *this;
  }

  RenderPipelineDesc& SetDepthStencilFormat(PixelFormat _depthStencilFormat)
  {
    depthStencilFormat = _depthStencilFormat;
    return *this;
  }

  RenderPipelineDesc& SetPrimitiveTopology(PrimitiveType _primitiveTopology)
  {
    primitiveTopology = _primitiveTopology;
    return *this;
  }

  RenderPipelineDesc& SetVertexFunction(Function * _vertexFunction)
  {
    vertexFunction = _vertexFunction;
    return *this;
  }

  RenderPipelineDesc& SetPixelFunction(Function * _pixelFunction)
  {
    pixelFunction = _pixelFunction;
    return *this;
  }

  RenderPipelineDesc& SetDeviceMask(uint64_t _deviceMask)
  {
    deviceMask = _deviceMask;
    return *this;
  }
};

static_assert(sizeof(RenderPipelineDesc) == sizeof(ngfxRenderPipelineDesc), "RenderPipelineDesc & ngfxRenderPipelineDesc Size Not Equal!");

struct ShaderBinding
{
  const char * name;
  EnumAsUint32<ShaderStageBit> visibility;
  BindingType bindingType;
  uint32_t slot;
  uint32_t count;

  ShaderBinding(const char * _name = nullptr, ShaderStageBit _visibility = ShaderStageBit::Vertex, BindingType _bindingType = BindingType::UniformBuffer, uint32_t _slot = 0, uint32_t _count = 0)
  : name(_name)
  , visibility(_visibility)
  , bindingType(_bindingType)
  , slot(_slot)
  , count(_count)
  {  }

  ShaderBinding& SetName(const char * _name)
  {
    name = _name;
    return *this;
  }

  ShaderBinding& SetVisibility(ShaderStageBit _visibility)
  {
    visibility = _visibility;
    return *this;
  }

  ShaderBinding& SetBindingType(BindingType _bindingType)
  {
    bindingType = _bindingType;
    return *this;
  }

  ShaderBinding& SetSlot(uint32_t _slot)
  {
    slot = _slot;
    return *this;
  }

  ShaderBinding& SetCount(uint32_t _count)
  {
    count = _count;
    return *this;
  }
};

static_assert(sizeof(ShaderBinding) == sizeof(ngfxShaderBinding), "ShaderBinding & ngfxShaderBinding Size Not Equal!");

// Description of Pipeline Layout (How to layout bindings)
struct PipelineLayoutDesc
{
  const BindTableEncoder * pTableEncoders;
  uint32_t shaderLayoutCount;

  PipelineLayoutDesc(const BindTableEncoder * _pTableEncoders = nullptr, uint32_t _shaderLayoutCount = 0)
  : pTableEncoders(_pTableEncoders)
  , shaderLayoutCount(_shaderLayoutCount)
  {  }

  PipelineLayoutDesc& SetPTableEncoders(const BindTableEncoder * _pTableEncoders)
  {
    pTableEncoders = _pTableEncoders;
    return *this;
  }

  PipelineLayoutDesc& SetShaderLayoutCount(uint32_t _shaderLayoutCount)
  {
    shaderLayoutCount = _shaderLayoutCount;
    return *this;
  }
};

static_assert(sizeof(PipelineLayoutDesc) == sizeof(ngfxPipelineLayoutDesc), "PipelineLayoutDesc & ngfxPipelineLayoutDesc Size Not Equal!");

struct AttachmentDesc
{
  LoadAction loadAction;
  StoreAction storeAction;
  Texture * texture;

  AttachmentDesc(LoadAction _loadAction = LoadAction::Load, StoreAction _storeAction = StoreAction::Store, Texture * _texture = nullptr)
  : loadAction(_loadAction)
  , storeAction(_storeAction)
  , texture(_texture)
  {  }

  AttachmentDesc& SetLoadAction(LoadAction _loadAction)
  {
    loadAction = _loadAction;
    return *this;
  }

  AttachmentDesc& SetStoreAction(StoreAction _storeAction)
  {
    storeAction = _storeAction;
    return *this;
  }

  AttachmentDesc& SetTexture(Texture * _texture)
  {
    texture = _texture;
    return *this;
  }
};

static_assert(sizeof(AttachmentDesc) == sizeof(ngfxAttachmentDesc), "AttachmentDesc & ngfxAttachmentDesc Size Not Equal!");

struct ColorAttachmentDesc : public AttachmentDesc
{
  Float32x4 clearColor;

  ColorAttachmentDesc(Float32x4 _clearColor = Float32x4())
  : AttachmentDesc()
  , clearColor(_clearColor)
  {  }

  ColorAttachmentDesc& SetClearColor(Float32x4 _clearColor)
  {
    clearColor = _clearColor;
    return *this;
  }
};

static_assert(sizeof(ColorAttachmentDesc) == sizeof(ngfxColorAttachmentDesc), "ColorAttachmentDesc & ngfxColorAttachmentDesc Size Not Equal!");

struct DepthStencilAttachmentDesc : public AttachmentDesc
{
  Float32 clearDepth;
  int32_t clearStencil;

  DepthStencilAttachmentDesc(Float32 _clearDepth = 0, int32_t _clearStencil = 0)
  : AttachmentDesc()
  , clearDepth(_clearDepth)
  , clearStencil(_clearStencil)
  {  }

  DepthStencilAttachmentDesc& SetClearDepth(Float32 _clearDepth)
  {
    clearDepth = _clearDepth;
    return *this;
  }

  DepthStencilAttachmentDesc& SetClearStencil(int32_t _clearStencil)
  {
    clearStencil = _clearStencil;
    return *this;
  }
};

static_assert(sizeof(DepthStencilAttachmentDesc) == sizeof(ngfxDepthStencilAttachmentDesc), "DepthStencilAttachmentDesc & ngfxDepthStencilAttachmentDesc Size Not Equal!");

// Description of Render Pass
struct RenderPassDesc
{
  ColorAttachmentDesc * pColorAttachments;
  int32_t colorAttachmentsCount;
  DepthStencilAttachmentDesc * pDepthStencilAttachment;

  RenderPassDesc(ColorAttachmentDesc * _pColorAttachments = nullptr, int32_t _colorAttachmentsCount = 0, DepthStencilAttachmentDesc * _pDepthStencilAttachment = nullptr)
  : pColorAttachments(_pColorAttachments)
  , colorAttachmentsCount(_colorAttachmentsCount)
  , pDepthStencilAttachment(_pDepthStencilAttachment)
  {  }

  RenderPassDesc& SetPColorAttachments(ColorAttachmentDesc * _pColorAttachments)
  {
    pColorAttachments = _pColorAttachments;
    return *this;
  }

  RenderPassDesc& SetColorAttachmentsCount(int32_t _colorAttachmentsCount)
  {
    colorAttachmentsCount = _colorAttachmentsCount;
    return *this;
  }

  RenderPassDesc& SetPDepthStencilAttachment(DepthStencilAttachmentDesc * _pDepthStencilAttachment)
  {
    pDepthStencilAttachment = _pDepthStencilAttachment;
    return *this;
  }
};

static_assert(sizeof(RenderPassDesc) == sizeof(ngfxRenderPassDesc), "RenderPassDesc & ngfxRenderPassDesc Size Not Equal!");

// Description of frame buffer
struct FrameBufferDesc
{
  Texture * colorAttachments[8];
  Texture * depthStencilAttachment;
  uint32_t layers;

  FrameBufferDesc(Texture * _depthStencilAttachment = nullptr, uint32_t _layers = 0)
  : depthStencilAttachment(_depthStencilAttachment)
  , layers(_layers)
  {
    memset(colorAttachments, 0, sizeof(colorAttachments));
  }

  FrameBufferDesc& SetColorAttachment(int index, Texture * _colorAttachments)
  {
    colorAttachments[index] = _colorAttachments;
    return *this;
  }

  FrameBufferDesc& SetDepthStencilAttachment(Texture * _depthStencilAttachment)
  {
    depthStencilAttachment = _depthStencilAttachment;
    return *this;
  }

  FrameBufferDesc& SetLayers(uint32_t _layers)
  {
    layers = _layers;
    return *this;
  }
};

static_assert(sizeof(FrameBufferDesc) == sizeof(ngfxFrameBufferDesc), "FrameBufferDesc & ngfxFrameBufferDesc Size Not Equal!");

struct DrawIndexedInstancedDesc
{
  uint32_t indexCountPerInstance;
  uint32_t instanceCount;
  uint32_t startId;
  uint32_t baseVertexId;
  uint32_t startInstanceId;

  DrawIndexedInstancedDesc(uint32_t _indexCountPerInstance = 0, uint32_t _instanceCount = 0, uint32_t _startId = 0, uint32_t _baseVertexId = 0, uint32_t _startInstanceId = 0)
  : indexCountPerInstance(_indexCountPerInstance)
  , instanceCount(_instanceCount)
  , startId(_startId)
  , baseVertexId(_baseVertexId)
  , startInstanceId(_startInstanceId)
  {  }

  DrawIndexedInstancedDesc& SetIndexCountPerInstance(uint32_t _indexCountPerInstance)
  {
    indexCountPerInstance = _indexCountPerInstance;
    return *this;
  }

  DrawIndexedInstancedDesc& SetInstanceCount(uint32_t _instanceCount)
  {
    instanceCount = _instanceCount;
    return *this;
  }

  DrawIndexedInstancedDesc& SetStartId(uint32_t _startId)
  {
    startId = _startId;
    return *this;
  }

  DrawIndexedInstancedDesc& SetBaseVertexId(uint32_t _baseVertexId)
  {
    baseVertexId = _baseVertexId;
    return *this;
  }

  DrawIndexedInstancedDesc& SetStartInstanceId(uint32_t _startInstanceId)
  {
    startInstanceId = _startInstanceId;
    return *this;
  }
};

static_assert(sizeof(DrawIndexedInstancedDesc) == sizeof(ngfxDrawIndexedInstancedDesc), "DrawIndexedInstancedDesc & ngfxDrawIndexedInstancedDesc Size Not Equal!");

struct DrawInstancedDesc
{
  uint32_t vertexCountPerInstance;
  uint32_t instanceCount;
  uint32_t startVertexId;
  uint32_t startInstanceId;

  DrawInstancedDesc(uint32_t _vertexCountPerInstance = 0, uint32_t _instanceCount = 0, uint32_t _startVertexId = 0, uint32_t _startInstanceId = 0)
  : vertexCountPerInstance(_vertexCountPerInstance)
  , instanceCount(_instanceCount)
  , startVertexId(_startVertexId)
  , startInstanceId(_startInstanceId)
  {  }

  DrawInstancedDesc& SetVertexCountPerInstance(uint32_t _vertexCountPerInstance)
  {
    vertexCountPerInstance = _vertexCountPerInstance;
    return *this;
  }

  DrawInstancedDesc& SetInstanceCount(uint32_t _instanceCount)
  {
    instanceCount = _instanceCount;
    return *this;
  }

  DrawInstancedDesc& SetStartVertexId(uint32_t _startVertexId)
  {
    startVertexId = _startVertexId;
    return *this;
  }

  DrawInstancedDesc& SetStartInstanceId(uint32_t _startInstanceId)
  {
    startInstanceId = _startInstanceId;
    return *this;
  }
};

static_assert(sizeof(DrawInstancedDesc) == sizeof(ngfxDrawInstancedDesc), "DrawInstancedDesc & ngfxDrawInstancedDesc Size Not Equal!");

struct Viewport
{
  Float32 left, top;
  Float32 width, height;
  Float32 minDepth;
  Float32 maxDepth;

  Viewport(Float32 _left = 0, Float32 _top = 0, Float32 _width = 0, Float32 _height = 0, Float32 _minDepth = 0, Float32 _maxDepth = 0)
  : left(_left)
  , top(_top)
  , width(_width)
  , height(_height)
  , minDepth(_minDepth)
  , maxDepth(_maxDepth)
  {  }

  Viewport& SetLeftTop(Float32 _left, Float32 _top)
  {
    left = _left;
    top = _top;
    return *this;
  }

  Viewport& SetWidthHeight(Float32 _width, Float32 _height)
  {
    width = _width;
    height = _height;
    return *this;
  }

  Viewport& SetMinDepth(Float32 _minDepth)
  {
    minDepth = _minDepth;
    return *this;
  }

  Viewport& SetMaxDepth(Float32 _maxDepth)
  {
    maxDepth = _maxDepth;
    return *this;
  }
};

static_assert(sizeof(Viewport) == sizeof(ngfxViewport), "Viewport & ngfxViewport Size Not Equal!");

struct SwapChainDesc
{
  PixelFormat pixelFormat;
  uint32_t width;
  uint32_t height;
  uint32_t numColorBuffers;
  Bool32 hasDepthStencilTarget;
  PixelFormat depthStencilFormat;

  SwapChainDesc(PixelFormat _pixelFormat = PixelFormat::RGBA16Uint, uint32_t _width = 0, uint32_t _height = 0, uint32_t _numColorBuffers = 0, Bool32 _hasDepthStencilTarget = 0, PixelFormat _depthStencilFormat = PixelFormat::RGBA16Uint)
  : pixelFormat(_pixelFormat)
  , width(_width)
  , height(_height)
  , numColorBuffers(_numColorBuffers)
  , hasDepthStencilTarget(_hasDepthStencilTarget)
  , depthStencilFormat(_depthStencilFormat)
  {  }

  SwapChainDesc& SetPixelFormat(PixelFormat _pixelFormat)
  {
    pixelFormat = _pixelFormat;
    return *this;
  }

  SwapChainDesc& SetWidth(uint32_t _width)
  {
    width = _width;
    return *this;
  }

  SwapChainDesc& SetHeight(uint32_t _height)
  {
    height = _height;
    return *this;
  }

  SwapChainDesc& SetNumColorBuffers(uint32_t _numColorBuffers)
  {
    numColorBuffers = _numColorBuffers;
    return *this;
  }

  SwapChainDesc& SetHasDepthStencilTarget(Bool32 _hasDepthStencilTarget)
  {
    hasDepthStencilTarget = _hasDepthStencilTarget;
    return *this;
  }

  SwapChainDesc& SetDepthStencilFormat(PixelFormat _depthStencilFormat)
  {
    depthStencilFormat = _depthStencilFormat;
    return *this;
  }
};

static_assert(sizeof(SwapChainDesc) == sizeof(ngfxSwapChainDesc), "SwapChainDesc & ngfxSwapChainDesc Size Not Equal!");

struct ShaderOption
{
  ShaderType stage;
  ShaderLang language;
  const char * entryName;
  ShaderProfile profile;
  ShaderFormat format;

  ShaderOption(ShaderType _stage = ShaderType::Vertex, ShaderLang _language = ShaderLang::HLSL, const char * _entryName = nullptr, ShaderProfile _profile = ShaderProfile::SM4, ShaderFormat _format = ShaderFormat::Text)
  : stage(_stage)
  , language(_language)
  , entryName(_entryName)
  , profile(_profile)
  , format(_format)
  {  }

  ShaderOption& SetStage(ShaderType _stage)
  {
    stage = _stage;
    return *this;
  }

  ShaderOption& SetLanguage(ShaderLang _language)
  {
    language = _language;
    return *this;
  }

  ShaderOption& SetEntryName(const char * _entryName)
  {
    entryName = _entryName;
    return *this;
  }

  ShaderOption& SetProfile(ShaderProfile _profile)
  {
    profile = _profile;
    return *this;
  }

  ShaderOption& SetFormat(ShaderFormat _format)
  {
    format = _format;
    return *this;
  }
};

static_assert(sizeof(ShaderOption) == sizeof(ngfxShaderOption), "ShaderOption & ngfxShaderOption Size Not Equal!");

struct ArgumentDesc
{
  DataType dataType;
  int32_t index;
  EnumAsUint32<ArgumentAccess> access;
  int32_t arrayLength;
  TextureDimension textureDim;
  int32_t bufferAlignment;
  EnumAsUint32<ShaderStageBit> stage;

  ArgumentDesc(DataType _dataType = DataType::None, int32_t _index = 0, ArgumentAccess _access = ArgumentAccess::ReadOnly, int32_t _arrayLength = 0, TextureDimension _textureDim = TextureDimension::Tex1D, int32_t _bufferAlignment = 0, ShaderStageBit _stage = ShaderStageBit::Vertex)
  : dataType(_dataType)
  , index(_index)
  , access(_access)
  , arrayLength(_arrayLength)
  , textureDim(_textureDim)
  , bufferAlignment(_bufferAlignment)
  , stage(_stage)
  {  }

  ArgumentDesc& SetDataType(DataType _dataType)
  {
    dataType = _dataType;
    return *this;
  }

  ArgumentDesc& SetIndex(int32_t _index)
  {
    index = _index;
    return *this;
  }

  ArgumentDesc& SetAccess(ArgumentAccess _access)
  {
    access = _access;
    return *this;
  }

  ArgumentDesc& SetArrayLength(int32_t _arrayLength)
  {
    arrayLength = _arrayLength;
    return *this;
  }

  ArgumentDesc& SetTextureDim(TextureDimension _textureDim)
  {
    textureDim = _textureDim;
    return *this;
  }

  ArgumentDesc& SetBufferAlignment(int32_t _bufferAlignment)
  {
    bufferAlignment = _bufferAlignment;
    return *this;
  }

  ArgumentDesc& SetStage(ShaderStageBit _stage)
  {
    stage = _stage;
    return *this;
  }
};

static_assert(sizeof(ArgumentDesc) == sizeof(ngfxArgumentDesc), "ArgumentDesc & ngfxArgumentDesc Size Not Equal!");

struct CompileOption
{
  Bool32 stripDebugSymbols;
  Bool32 optimizeSize;
  ShaderLang language;
  ShaderProfile profile;
  ShaderFormat format;

  CompileOption(Bool32 _stripDebugSymbols = 0, Bool32 _optimizeSize = 0, ShaderLang _language = ShaderLang::HLSL, ShaderProfile _profile = ShaderProfile::SM4, ShaderFormat _format = ShaderFormat::Text)
  : stripDebugSymbols(_stripDebugSymbols)
  , optimizeSize(_optimizeSize)
  , language(_language)
  , profile(_profile)
  , format(_format)
  {  }

  CompileOption& SetStripDebugSymbols(Bool32 _stripDebugSymbols)
  {
    stripDebugSymbols = _stripDebugSymbols;
    return *this;
  }

  CompileOption& SetOptimizeSize(Bool32 _optimizeSize)
  {
    optimizeSize = _optimizeSize;
    return *this;
  }

  CompileOption& SetLanguage(ShaderLang _language)
  {
    language = _language;
    return *this;
  }

  CompileOption& SetProfile(ShaderProfile _profile)
  {
    profile = _profile;
    return *this;
  }

  CompileOption& SetFormat(ShaderFormat _format)
  {
    format = _format;
    return *this;
  }
};

static_assert(sizeof(CompileOption) == sizeof(ngfxCompileOption), "CompileOption & ngfxCompileOption Size Not Equal!");

struct BindTableEncoder : public RefCounted<true>
{
  virtual Result Allocate(BindTable ** ppBindTable) = 0;
};

// Present drawables
struct SwapChain : public NamedObject<true>
{
  virtual Drawable * CurrentDrawable() = 0;
  virtual Drawable * NextDrawable() = 0;
  virtual Result GetTexture(Texture ** ppTexture, uint32_t index) = 0;
  virtual uint32_t BufferCount() = 0;
  virtual void InitWithRenderPass(RenderPass * pRenderPass) = 0;
};

struct Function : public RefCounted<true>
{
  virtual ShaderType Type() const = 0;
  virtual const char * Name() const = 0;
};

struct Library : public RefCounted<true>
{
  virtual Result MakeFunction(const char * name, Function ** ppFunction) = 0;
};

// For shader reflection
struct VariableType : public RefCounted<true>
{
  virtual DataType GetType() = 0;
};

// For shader reflection
struct Variable : public RefCounted<true>
{
  virtual const char * Name() = 0;
  virtual ArgumentAccess Access() = 0;
  virtual VariableType * Type() = 0;
  virtual uint32_t Index() = 0;
  virtual bool Active() = 0;
  virtual ShaderType GetStage() const = 0;
};

// Not ready yet
struct StructType : public VariableType
{
};

// uniform buffer
struct ArrayType : public VariableType
{
  virtual uint32_t Length() = 0;
  virtual DataType ElementType() = 0;
  virtual uint32_t Stride() = 0;
  virtual VariableType * Elements() = 0;
};

// storage class buffer
struct PointerType : public VariableType
{
  virtual ArgumentAccess Access() = 0;
  virtual uint32_t Alignment() = 0;
  virtual uint32_t DataSize() = 0;
  virtual DataType ElementType() = 0;
};

struct TextureReferType : public VariableType
{
  virtual ArgumentAccess Access() = 0;
  virtual DataType TextureDataType() = 0;
  virtual TextureDimension TextureDim() = 0;
};

struct PipelineReflection : public RefCounted<true>
{
  virtual uint32_t VariableCount() const = 0;
  virtual Variable * VariableAt(uint32_t id) const = 0;
  virtual Result Merge(const PipelineReflection * pReflection) = 0;
};

struct ShaderCompiler : public RefCounted<true>
{
  virtual Result Compile(CompileOption option, const char * code, size_t length) = 0;
};

// Create devices and swapchains
struct Factory : public NamedObject<true>
{
  virtual Result EnumDevice(uint32_t * count, Device ** ppDevice) = 0;
  virtual Result CreateSwapchain(NotNull const SwapChainDesc * desc, NotNull CommandQueue * pCommandQueue, void * pWindow, NotNull SwapChain ** pSwapchain) = 0;
};

struct FrameBuffer : public NamedObject<true>
{
  virtual Bool32 CompatWith(const RenderPass * pRenderPass) = 0;
};

struct RenderPass : public NamedObject<true>
{
  virtual Result MakeFrameBuffer(const TextureView ** pRenderTargetViews, int32_t viewCount, int32_t width, int32_t height, int32_t layers, FrameBuffer ** ppFramebuffer) = 0;
  virtual Result MakeRenderPipeline(NotNull const RenderPipelineDesc * pPipelineDesc, NotNull const PipelineLayout * pPipelineLayout, Pipeline ** ppPipeline) = 0;
};

struct Pipeline : public NamedObject<true>
{
  virtual PipelineType Type() const = 0;
  virtual Result GetCache(uint64_t * pSize, void * pOutData) = 0;
};

struct PipelineLibrary : public RefCounted<true>
{
  virtual void StorePipeline(const char * key, Pipeline * pPipeline) = 0;
  virtual uint64_t GetSerializedSize() const = 0;
  virtual void Serialize(void * pData, uint64_t Size) = 0;
};

struct ComputePipeline : public Pipeline
{
};

struct RenderPipeline : public Pipeline
{
  virtual Result GetDesc(RenderPipelineDesc * pDesc) = 0;
};

struct PipelineLayout : public NamedObject<true>
{
};

// Shader binding table
struct BindTable : public NamedObject<true>
{
  virtual void SetSampler(uint32_t index, ShaderType shaderVis, Sampler * pSampler) = 0;
  virtual void SetBuffer(uint32_t index, ShaderType shaderVis, BufferView * bufferView) = 0;
  virtual void SetTexture(uint32_t index, ShaderType shaderVis, TextureView * textureView) = 0;
};

struct Sampler : public NamedObject<true>
{
  virtual Result GetDesc(SamplerDesc * desc) = 0;
};

struct Resource : public NamedObject<true>
{
  virtual void * Map(uint64_t offset, uint64_t size) = 0;
  virtual void UnMap() = 0;
};

struct Buffer : public Resource
{
  virtual Result GetDesc(BufferDesc * pDesc) = 0;
  virtual Result CreateView(const BufferViewDesc * pDesc, BufferView ** ppView) = 0;
};

struct BufferView : public NamedObject<true>
{
};

struct Texture : public Resource
{
  virtual Result GetDesc(TextureDesc * pDesc) = 0;
  virtual Result CreateView(const TextureViewDesc * pDesc, TextureView ** ppView) = 0;
};

struct TextureView : public NamedObject<true>
{
};

struct Drawable : public RefCounted<true>
{
  virtual Texture * Texture() = 0;
};

// Gpu device
struct Device : public NamedObject<true>
{
  virtual void GetDesc(NotNull DeviceDesc * pDesc) = 0;
  virtual Result CreateCommandQueue(CommandQueueType queueType, CommandQueue ** pQueue) = 0;
  virtual Result CreateShaderCompiler(ShaderCompiler ** ppCompiler) = 0;
  virtual Result CreatePipelineLayout(NotNull const PipelineLayoutDesc * pPipelineLayoutDesc, PipelineLayout ** ppPipelineLayout) = 0;
  virtual Result MakeBindTableEncoder(NotNull const ArgumentDesc * pArgumentDescs, int32_t argumentCount, BindTableEncoder ** ppBindingTableLayout) = 0;
  virtual Result CreateRenderPipeline(NotNull const RenderPipelineDesc * pPipelineDesc, Nullable RenderPass * pRenderPass, Pipeline ** pPipelineState, NotNull PipelineReflection ** ppReflection) = 0;
  virtual Result CreateComputePipeline(NotNull Function * pComputeFunction, Pipeline ** ppPipeline, NotNull PipelineReflection ** ppReflection) = 0;
  virtual Result CreateComputePipeline(NotNull const Function * pComputeFunction, NotNull const PipelineLayout * ppPipelineLayout, NotNull Pipeline ** ppPipeline) = 0;
  virtual Result CreatePipelineLibrary(const void * pData, uint64_t Size, PipelineLibrary ** ppPipelineLibrary) = 0;
  virtual Result CreateLibrary(const CompileOption * compileOption, const void * pData, uint64_t Size, Library ** ppLibrary) = 0;
  virtual Result CreateRenderPass(NotNull const RenderPassDesc * desc, RenderPass ** ppRenderpass) = 0;
  virtual Result CreateSampler(NotNull const SamplerDesc* desc, Sampler ** pSampler) = 0;
  virtual Result CreateBuffer(NotNull const BufferDesc* desc, Buffer ** pBuffer) = 0;
  virtual Result CreateTexture(NotNull const TextureDesc * desc, Texture ** pTexture) = 0;
  virtual Result CreateFence(Fence ** ppFence) = 0;
  virtual void WaitIdle() = 0;
};

struct Fence : public NamedObject<true>
{
  virtual void Wait() = 0;
  virtual void Reset() = 0;
};

struct CommandQueue : public NamedObject<true>
{
  virtual Result CreateCommandBuffer(CommandBuffer ** ppComandBuffer) = 0;
};

// Gpu Command Buffer
struct CommandBuffer : public NamedObject<true>
{
  virtual void Commit(Fence * pFence) = 0;
  virtual Result CreateRenderCommandEncoder(Drawable * pDrawable, RenderPass * pRenderPass, RenderCommandEncoder ** ppRenderCommandEncoder) = 0;
  virtual Result CreateComputeCommandEncoder(ComputeCommandEncoder ** ppComputeCommandEncoder) = 0;
  virtual Result CreateCopyCommandEncoder(CopyCommandEncoder ** ppCopyCommandEncoder) = 0;
  virtual Result CreateParallelCommandEncoder(ParallelRenderCommandEncoder ** ppCopyCommandEncoder) = 0;
};

struct CommandEncoder : public NamedObject<true>
{
  virtual void Barrier(Resource * pResource) = 0;
  virtual void SetPipeline(Pipeline* pPipelineState) = 0;
  virtual void SetBindTable(BindTable * pBindingTable) = 0;
  virtual void EndEncode() = 0;
};

// Command Encoder used for Copy and Blit
struct CopyCommandEncoder : public CommandEncoder
{
  virtual void CopyTexture() = 0;
  virtual void CopyBuffer(uint64_t srcOffset, uint64_t dstOffset, uint64_t size, Buffer * srcBuffer, Buffer * dstBuffer) = 0;
};

// Render Command Encoder
struct RenderCommandEncoder : public CommandEncoder
{
  virtual void SetScissorRect(uint32_t x, uint32_t y, uint32_t w, uint32_t h) = 0;
  virtual void SetViewport(const Viewport * pViewport) = 0;
  virtual void SetDepthBias(Float32 biasConst, Float32 biasClamp, Float32 biasSlope) = 0;
  virtual void SetDepthBounds(Float32 minDepth, Float32 maxDepth) = 0;
  virtual void SetStencilReference(StencilFaceRef face, uint32_t value) = 0;
  virtual void SetBlendConsts(Float32x4 constant) = 0;
  virtual void SetLineWidth(Float32 width) = 0;
  virtual void SetIndexBuffer(Buffer * pIndexBuffer, IndexBufferType type) = 0;
  virtual void SetVertexBuffer(uint32_t slot, uint64_t offset, Buffer * pVertexBuffer) = 0;
  virtual void DrawInstanced(const DrawInstancedDesc * drawParam) = 0;
  virtual void DrawIndexedInstanced(const DrawIndexedInstancedDesc * drawParam) = 0;
  virtual void DrawIndirect(Buffer * pIndirectBuffer, uint32_t offset, uint32_t drawCount, uint32_t stride) = 0;
  virtual void Present(Drawable * pDrawable) = 0;
};

struct ComputeCommandEncoder : public CommandEncoder
{
  virtual void Dispatch(uint32_t x, uint32_t y, uint32_t z) = 0;
};

struct ParallelRenderCommandEncoder : public CommandEncoder
{
  virtual RenderCommandEncoder * Encoder() = 0;
};

extern "C" Result NGFX_API CreateFactory(Factory ** ppFactory, bool debugEnabled);

#if ENABLE_UNITY_PLUGIN
extern "C" Result NGFX_API DeviceFromUnity(Device ** ppDevice, UnityGfxRenderer unityRenderer, void * pUnityDevice);
#endif

} // namespace ngfx
#endif // __cplusplus

#endif // __NGFX__
